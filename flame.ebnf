(* =========================
   Flame — EBNF
   ========================= *)

programa        = { declaracao | comando } EOF ;

(* ---------- Declarações ---------- *)

declaracao      = decl_variavel
                | decl_constante
                | decl_sensor
                | decl_atuador
                ;

decl_variavel   = "variavel" ident [ ":" tipo ] [ "=" expressao ] ";" ;
decl_constante  = "constante" ident [ ":" tipo ] "=" expressao ";" ;
decl_sensor     = "sensor" lista_idents [ ":" tipo ] ";" ;
decl_atuador    = "atuador" lista_idents [ ":" tipo ] ";" ;

lista_idents    = ident { "," ident } ;

tipo            = "numero" | "logico" | "texto" ;

(* ---------- Comandos ---------- *)

comando         = bloco
                | cmd_se
                | cmd_enquanto
                | cmd_repita
                | cmd_atribuicao
                | cmd_mostrar
                | cmd_esperar
                | cmd_instrucao
                | ";"                 (* comando vazio *)
                ;

(* Bloco legível para iniciantes *)
bloco           = "inicio" { declaracao | comando } "fim" ;

(* SE / SENAO legível *)
cmd_se          = "se" "(" expressao ")" "entao" comando
                  { "senao se" "(" expressao ")" "entao" comando }
                  [ "senao" comando ]
                  "fimse" ;

(* ENQUANTO ... FACA ... FIMENQUANTO *)
cmd_enquanto    = "enquanto" "(" expressao ")" "faca" comando "fimenquanto" ;

(* REPITA ... ATE (condicao);  — útil para ciclos com espera *)
cmd_repita      = "repita" comando "ate" "(" expressao ")" ";" ;

(* Mostrar mensagens/valores no console/painel *)
cmd_mostrar     = "mostrar" "(" lista_args ")" ";" ;

(* Esperar milissegundos *)
cmd_esperar     = "esperar" "(" inteiro ")" ";" ;

(* Ponte para instrução nativa/VM específica *)
cmd_instrucao   = "instrucao" ident "(" [ lista_args ] ")" ";" ;

(* Atribuição *)
cmd_atribuicao  = lista_atr ";" ;
lista_atr       = atr { "," atr } ;
atr             = lvalue "=" expressao ;

lvalue          = ident
                | ident "[" expressao "]"        (* acesso a memória/vetor *)
                ;

(* ---------- Expressões (com operadores em português) ---------- *)

expressao       = atrib ;

(* Atribuição em expressões é opcional para simplificar — mantemos separado *)
atrib           = log_ou ;

log_ou          = log_e { "ou" log_e } ;
log_e           = igualdade { "e" igualdade } ;

igualdade       = rel { ( "==" | "!=" ) rel } ;
rel             = soma { ( "<" | "<=" | ">" | ">=" ) soma } ;
soma            = termo { ( "+" | "-" ) termo } ;
termo           = unario { ( "*" | "/" | "%" ) unario } ;

unario          = [ "nao" | "-" | "+" ] unario | primario ;

primario        = literal
                | lvalue
                | chamada
                | "(" expressao ")"
                ;

chamada         = ident "(" [ lista_args ] ")" ;
lista_args      = expressao { "," expressao } ;

literal         = inteiro | real | booleano | string ;

(* ---------- Léxico (tokens) ---------- *)

ident           = letra { letra | digito | "_" } ;
inteiro         = "0" | ( digito_nz { digito } ) ;
real            = inteiro "." { digito } ;
booleano        = "verdadeiro" | "falso" ;
string          = "\"" { caractere_string } "\"" ;

letra           = "A"…"Z" | "a"…"z" ;
digito          = "0"…"9" ;
digito_nz       = "1"…"9" ;

caractere_string = ? qualquer caractere exceto " ou \ ou nova-linha ?
                  | "\\" ( "\"" | "\\" | "n" | "t" | "r" ) ;

(* ---------- Espaços e comentários ---------- *)
WS              = ( " " | "\t" | "\r" | "\n" ) ;
coment_linha    = "//" { ? não-nova-linha ? } ( "\n" | EOF ) ;
coment_bloco    = "/*" { ? qualquer caractere ? } "*/" ;
